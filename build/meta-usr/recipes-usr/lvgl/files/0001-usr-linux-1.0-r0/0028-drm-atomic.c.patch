--- /home/rossierd/soo/infrabase/build/tmp/work/usr-linux-1.0-r0/usr-linux-1.0/src/graphic/fb_benchmark/drm-atomic.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/graphic/fb_benchmark/drm-atomic.c	2025-09-03 16:56:16.389734217 +0200
@@ -0,0 +1,436 @@
+/*
+ * Copyright (c) 2017 Rob Clark <rclark@redhat.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <poll.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <linux/dma-buf.h>
+#include <sys/ioctl.h>
+
+#include "common.h"
+#include "drm-common.h"
+#include "draw.h"
+
+#define VOID2U64(x) ((uint64_t)(unsigned long)(x))
+
+static struct drm drm = {
+	.kms_out_fence_fd = -1,
+	.drm_atomic_page_flip_enabled = false,
+};
+
+static int waiting_for_flip;
+
+static void page_flip_handler(int fd, unsigned int frame,
+		unsigned int sec, unsigned int usec, void *data)
+{
+	/* suppress 'unused parameter' warnings */
+	(void)fd, (void)frame, (void)sec, (void)usec;
+
+	waiting_for_flip = 0;
+}
+
+static int add_connector_property(drmModeAtomicReq *req, uint32_t obj_id,
+		const char *name, uint64_t value)
+{
+	struct connector *obj = drm.connector;
+	unsigned int i;
+	int prop_id = 0;
+
+	for (i = 0 ; i < obj->props->count_props ; i++) {
+		if (strcmp(obj->props_info[i]->name, name) == 0) {
+			prop_id = obj->props_info[i]->prop_id;
+			break;
+		}
+	}
+
+	if (prop_id < 0) {
+		printf("no connector property: %s\n", name);
+		return -EINVAL;
+	}
+
+	return drmModeAtomicAddProperty(req, obj_id, prop_id, value);
+}
+
+static int add_crtc_property(drmModeAtomicReq *req, uint32_t obj_id,
+		const char *name, uint64_t value)
+{
+	struct crtc *obj = drm.crtc;
+	unsigned int i;
+	int prop_id = -1;
+
+	for (i = 0 ; i < obj->props->count_props ; i++) {
+		if (strcmp(obj->props_info[i]->name, name) == 0) {
+			prop_id = obj->props_info[i]->prop_id;
+			break;
+		}
+	}
+
+	if (prop_id < 0) {
+		printf("no crtc property: %s\n", name);
+		return -EINVAL;
+	}
+
+	return drmModeAtomicAddProperty(req, obj_id, prop_id, value);
+}
+
+static int add_plane_property(drmModeAtomicReq *req, uint32_t obj_id,
+		const char *name, uint64_t value)
+{
+	struct plane *obj = drm.plane;
+	unsigned int i;
+	int prop_id = -1;
+
+	for (i = 0 ; i < obj->props->count_props ; i++) {
+		if (strcmp(obj->props_info[i]->name, name) == 0) {
+			prop_id = obj->props_info[i]->prop_id;
+			break;
+		}
+	}
+
+
+	if (prop_id < 0) {
+		printf("no plane property: %s\n", name);
+		return -EINVAL;
+	}
+
+	return drmModeAtomicAddProperty(req, obj_id, prop_id, value);
+}
+
+static int drm_atomic_commit(uint32_t fb_id, uint32_t flags)
+{
+	drmModeAtomicReq *req;
+	uint32_t plane_id = drm.plane->plane->plane_id;
+	uint32_t blob_id;
+	int ret;
+
+	req = NULL;
+	req = drmModeAtomicAlloc();
+
+	if (flags & DRM_MODE_ATOMIC_ALLOW_MODESET) {
+		if (add_connector_property(req, drm.connector_id, "CRTC_ID",
+					drm.crtc_id) < 0)
+			return -1;
+
+		if (drmModeCreatePropertyBlob(drm.fd, drm.mode, sizeof(*drm.mode),
+					&blob_id) != 0)
+			return -1;
+
+		if (add_crtc_property(req, drm.crtc_id, "MODE_ID", blob_id) < 0)
+			return -1;
+
+		if (add_crtc_property(req, drm.crtc_id, "ACTIVE", 1) < 0)
+			return -1;
+	}
+
+	add_plane_property(req, plane_id, "FB_ID", fb_id);
+	add_plane_property(req, plane_id, "CRTC_ID", drm.crtc_id);
+	add_plane_property(req, plane_id, "SRC_X", 0);
+	add_plane_property(req, plane_id, "SRC_Y", 0);
+	add_plane_property(req, plane_id, "SRC_W", drm.mode->hdisplay << 16);
+	add_plane_property(req, plane_id, "SRC_H", drm.mode->vdisplay << 16);
+	add_plane_property(req, plane_id, "CRTC_X", 0);
+	add_plane_property(req, plane_id, "CRTC_Y", 0);
+	add_plane_property(req, plane_id, "CRTC_W", drm.mode->hdisplay);
+	add_plane_property(req, plane_id, "CRTC_H", drm.mode->vdisplay);
+
+
+	ret = drmModeAtomicCommit(drm.fd, req, flags, NULL);
+	if (ret)
+		goto out;
+
+	if (drm.kms_in_fence_fd != -1) {
+		close(drm.kms_in_fence_fd);
+		drm.kms_in_fence_fd = -1;
+	}
+
+out:
+	drmModeAtomicFree(req);
+
+	return ret;
+}
+
+
+static int atomic_run(const struct gbm *gbm, struct dumb_buf *dumb_buf)
+{
+	struct drm_fb *fb;
+	uint32_t flags = 0;
+	int64_t report_time, cur_time;
+	int ret, res;
+	uint32_t frame_cnt;
+	uint32_t p_frame_cnt;
+	struct dma_buf_sync sync_rq;
+	struct gbm_bo *bo = NULL;
+	struct gbm_bo *next_bo;
+	struct drm_fb *next_fb;
+	struct pollfd pfd;
+	drmEventContext evctx = {
+		.version = 2,
+		.page_flip_handler = page_flip_handler,
+	};
+
+	if (drm.drm_atomic_page_flip_enabled == true) {
+		flags = DRM_MODE_ATOMIC_NONBLOCK | DRM_MODE_PAGE_FLIP_EVENT;
+		pfd.fd = drm.fd;
+		pfd.events = POLLIN;
+	}
+
+	/* Allow a modeset change for the first commit only. */
+	flags |= DRM_MODE_ATOMIC_ALLOW_MODESET;
+
+	report_time = get_time_ns();
+	p_frame_cnt = frame_cnt = 0;
+
+	while (frame_cnt < drm.count) {
+
+		if (gbm != NULL) {
+			/* GBM buffers */
+
+			if (gbm->surface) {
+				next_bo = gbm_surface_lock_front_buffer(gbm->surface);
+			} else {
+				next_bo = gbm->bos[frame_cnt % NUM_BUFFERS];
+			}
+
+			if (!next_bo) {
+				printf("Failed to lock frontbuffer\n");
+				return -1;
+			}
+
+			fb = drm_fb_get_from_bo(next_bo);
+			if (!fb) {
+				printf("Failed to get a new framebuffer BO\n");
+				return -1;
+			}
+
+			sync_rq.flags = DMA_BUF_SYNC_START | DMA_BUF_SYNC_RW;
+
+			if ((res = ioctl(fb->buf_handle, DMA_BUF_IOCTL_SYNC, &sync_rq)) != 0) {
+				printf("Failed to sync buffer\n");
+				return -1;
+			}
+
+			draw_solid_color(fb);
+
+			sync_rq.flags = DMA_BUF_SYNC_END | DMA_BUF_SYNC_RW;
+
+			if ((res = ioctl(fb->buf_handle, DMA_BUF_IOCTL_SYNC, &sync_rq)) != 0) {
+				printf("Failed to sync buffer\n");
+				return -1;
+			}
+
+		} else if (dumb_buf != NULL) {
+
+			/* Dumb buffers */
+			fb = drm_fb_get_dumb_buf(dumb_buf, frame_cnt % NUM_BUFFERS);
+			if (fb == NULL) {
+				printf("Failed to get a new framebuffer dumb buffer\n");
+				return -1;
+			}
+
+			draw_solid_color(fb);
+
+		} else {
+			printf("error invalid arguments\n");
+			return -1;
+		}
+
+		/*
+		 * Here you could also update drm plane layers if you want
+		 * hw composition
+		 */
+		ret = drm_atomic_commit(fb->fb_id, flags);
+		if (ret) {
+			printf("failed to commit: %s\n", strerror(errno));
+			return -1;
+		}
+
+		if (drm.drm_atomic_page_flip_enabled == true) {
+			waiting_for_flip = 1;
+			while (waiting_for_flip == 1) {
+				do {
+					ret = poll(&pfd, 1, -1);
+				} while(ret == -1 && errno == EINTR);
+
+				drmHandleEvent(drm.fd, &evctx);
+			}
+		}
+
+		cur_time = get_time_ns();
+		if (cur_time > (report_time + 1 * NSEC_PER_SEC)) {
+			double elapsed_time = cur_time - report_time;
+			double secs = elapsed_time / (double)NSEC_PER_SEC;
+			uint32_t delta_frames = frame_cnt - p_frame_cnt;
+			printf("Rendered %u frames in %f sec (%f fps)\n",
+					delta_frames, secs, (double) delta_frames / secs);
+			report_time = cur_time;
+			p_frame_cnt = frame_cnt;
+		}
+
+		if (gbm != NULL) {
+			/* release last buffer to render on again: */
+			if (bo && gbm->surface)
+				gbm_surface_release_buffer(gbm->surface, bo);
+
+			bo = next_bo;
+		}
+
+		/* Allow a modeset change for the first commit only - clear flag */
+		flags &= ~(DRM_MODE_ATOMIC_ALLOW_MODESET);
+		frame_cnt++;
+	}
+
+	return ret;
+}
+
+/* Pick a plane.. something that at a minimum can be connected to
+ * the chosen crtc, but prefer primary plane.
+ *
+ * Seems like there is some room for a drmModeObjectGetNamedProperty()
+ * type helper in libdrm..
+ */
+static int get_plane_id(void)
+{
+	drmModePlaneResPtr plane_resources;
+	uint32_t i, j;
+	int ret = -EINVAL;
+	int found_primary = 0;
+
+	plane_resources = drmModeGetPlaneResources(drm.fd);
+	if (!plane_resources) {
+		printf("drmModeGetPlaneResources failed: %s\n", strerror(errno));
+		return -1;
+	}
+
+	for (i = 0; (i < plane_resources->count_planes) && !found_primary; i++) {
+		uint32_t id = plane_resources->planes[i];
+		drmModePlanePtr plane = drmModeGetPlane(drm.fd, id);
+		if (!plane) {
+			printf("drmModeGetPlane(%u) failed: %s\n", id, strerror(errno));
+			continue;
+		}
+
+		if (plane->possible_crtcs & (1 << drm.crtc_index)) {
+			drmModeObjectPropertiesPtr props =
+				drmModeObjectGetProperties(drm.fd, id, DRM_MODE_OBJECT_PLANE);
+
+			/* primary or not, this plane is good enough to use: */
+			ret = id;
+
+			for (j = 0; j < props->count_props; j++) {
+				drmModePropertyPtr p =
+					drmModeGetProperty(drm.fd, props->props[j]);
+
+				if ((strcmp(p->name, "type") == 0) &&
+						(props->prop_values[j] == DRM_PLANE_TYPE_PRIMARY)) {
+					/* found our primary plane, lets use that: */
+					found_primary = 1;
+				}
+
+				drmModeFreeProperty(p);
+			}
+
+			drmModeFreeObjectProperties(props);
+		}
+
+		drmModeFreePlane(plane);
+	}
+
+	drmModeFreePlaneResources(plane_resources);
+
+	return ret;
+}
+
+struct drm * init_drm_atomic(const char *device, const char *mode_str,
+		int connector_id, unsigned int vrefresh, unsigned int count)
+{
+	uint32_t plane_id;
+	int ret;
+
+	ret = init_drm(&drm, device, mode_str, connector_id, vrefresh, count);
+	if (ret)
+		return NULL;
+
+	ret = drmSetClientCap(drm.fd, DRM_CLIENT_CAP_ATOMIC, 1);
+	if (ret) {
+		printf("no atomic modesetting support: %s\n", strerror(errno));
+		return NULL;
+	}
+
+	ret = get_plane_id();
+	if (!ret) {
+		printf("could not find a suitable plane\n");
+		return NULL;
+	} else {
+		plane_id = ret;
+	}
+
+	/* We only do single plane to single crtc to single connector, no
+	 * fancy multi-monitor or multi-plane stuff.  So just grab the
+	 * plane/crtc/connector property info for one of each:
+	 */
+	drm.plane = calloc(1, sizeof(*drm.plane));
+	drm.crtc = calloc(1, sizeof(*drm.crtc));
+	drm.connector = calloc(1, sizeof(*drm.connector));
+
+#define get_resource(type, Type, id) do { 					\
+	drm.type->type = drmModeGet##Type(drm.fd, id);			\
+	if (!drm.type->type) {						\
+		printf("could not get %s %i: %s\n",			\
+#type, id, strerror(errno));		\
+		return NULL;						\
+	}								\
+} while (0)
+
+	get_resource(plane, Plane, plane_id);
+	get_resource(crtc, Crtc, drm.crtc_id);
+	get_resource(connector, Connector, drm.connector_id);
+
+#define get_properties(type, TYPE, id) do {					\
+	uint32_t i;							\
+	drm.type->props = drmModeObjectGetProperties(drm.fd,		\
+			id, DRM_MODE_OBJECT_##TYPE);			\
+	if (!drm.type->props) {						\
+		printf("could not get %s %u properties: %s\n", 		\
+#type, id, strerror(errno));		\
+		return NULL;						\
+	}								\
+	drm.type->props_info = calloc(drm.type->props->count_props,	\
+			sizeof(*drm.type->props_info));			\
+	for (i = 0; i < drm.type->props->count_props; i++) {		\
+		drm.type->props_info[i] = drmModeGetProperty(drm.fd,	\
+				drm.type->props->props[i]);		\
+	}								\
+} while (0)
+
+	get_properties(plane, PLANE, plane_id);
+	get_properties(crtc, CRTC, drm.crtc_id);
+	get_properties(connector, CONNECTOR, drm.connector_id);
+
+	drm.run = atomic_run;
+
+	return &drm;
+	}
