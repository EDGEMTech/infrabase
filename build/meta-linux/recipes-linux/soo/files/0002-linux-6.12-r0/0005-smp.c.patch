--- /home/rossierd/soo/git/micofe/build/tmp/work/linux-6.12-r0/linux-6.12/arch/arm64/kernel/smp.c	2024-11-17 23:15:08.000000000 +0100
+++ ./arch/arm64/kernel/smp.c	2025-08-29 08:46:39.976376895 +0200
@@ -53,6 +53,8 @@
 #include <asm/ptrace.h>
 #include <asm/virt.h>
 
+#include <avz/uapi/avz.h>
+#include <soo/uapi/console.h>
 #include <trace/events/ipi.h>
 
 /*
@@ -67,7 +69,7 @@
 enum ipi_msg_type {
 	IPI_RESCHEDULE,
 	IPI_CALL_FUNC,
-	IPI_CPU_STOP,
+	IPI_CPU_STOP,	
 	IPI_CPU_STOP_NMI,
 	IPI_TIMER,
 	IPI_IRQ_WORK,
@@ -955,7 +957,7 @@
 static void do_handle_IPI(int ipinr)
 {
 	unsigned int cpu = smp_processor_id();
-
+	
 	if ((unsigned)ipinr < NR_IPI)
 		trace_ipi_entry(ipi_types[ipinr]);
 
@@ -969,6 +971,17 @@
 		break;
 
 	case IPI_CPU_STOP:
+
+/* Since we do not succeed in sending IPInr > NR_IPI, we are using IPI_CPU_STOP
+ * which should never be used in our context.
+ */
+#ifdef CONFIG_SOO
+		BUG_ON(IPI_EVENT_CHECK != IPI_CPU_STOP);
+		 
+		virq_handle(0);
+		break;
+#endif /* CONFIG_SOO */
+
 	case IPI_CPU_STOP_NMI:
 		if (IS_ENABLED(CONFIG_KEXEC_CORE) && crash_stop) {
 			ipi_cpu_crash_stop(cpu, get_irq_regs());
