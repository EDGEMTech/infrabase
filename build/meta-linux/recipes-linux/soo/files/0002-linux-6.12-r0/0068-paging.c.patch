--- /home/rossierd/soo/git/micofe/build/tmp/work/linux-6.12-r0/linux-6.12/soo/kernel/arm64/paging.c	1970-01-01 01:00:00.000000000 +0100
+++ ./soo/kernel/arm64/paging.c	2025-08-29 08:46:41.395097877 +0200
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2016-2021 Daniel Rossier <daniel.rossier@soo.tech>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/highmem.h>   
+
+#include <asm/pgtable.h>
+#include <asm/io.h>
+
+#include <soo/paging.h>
+
+struct uncached_page *alloc_uncached_zeroed_page(gfp_t gfp)
+{
+    struct page *pg;
+    void *va;
+    struct page *pages[1];
+    struct uncached_page *uncp;
+
+    uncp = kmalloc(sizeof(struct uncached_page), GFP_KERNEL);
+    BUG_ON(!uncp);
+   
+    pg = alloc_page(gfp | __GFP_ZERO);
+    BUG_ON(!pg);
+ 
+    pages[0] = pg;
+    va = vmap(pages, 1, VM_MAP, pgprot_noncached(PAGE_KERNEL));
+    BUG_ON(!va);
+    
+    uncp->vaddr = va;
+    uncp->pg  = pg;
+
+    return uncp;
+}
+
+void free_uncached_zeroed_page(struct uncached_page *p)
+{
+    if (!p) return;
+    vunmap(p->vaddr);       // unmap the uncached VA
+    __free_page(p->pg);   // free the physical page
+    kfree(p);
+}
+
+void *paging_remap(unsigned long paddr, size_t size) {
+	void *vaddr;
+
+	vaddr = ioremap_wc(paddr, size);
+	BUG_ON(!vaddr);
+
+	return vaddr;
+}
+
+void paging_remap_page_range(unsigned long vaddr, unsigned long end, phys_addr_t physaddr) {
+	int ret;
+
+	ret = ioremap_page_range(vaddr, end, physaddr, __pgprot(PROT_NORMAL_NC));
+	BUG_ON(ret);
+
+}
+
