--- /home/rossierd/soo/micofe/build/tmp/work/linux-6.12-r0/linux-6.12/soo/kernel/console/lprintk.c	1970-01-01 01:00:00.000000000 +0100
+++ ./soo/kernel/console/lprintk.c	2025-08-24 11:46:06.524235112 +0200
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) 2016-2018 Daniel Rossier <daniel.rossier@soo.tech>
+ * Copyright (C) 2019 Baptiste Delporte <bonel@bonel.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+#include <linux/kthread.h>
+#include <linux/mutex.h>
+#include <linux/console.h>
+
+#include <soo/dev/vuart.h>
+
+#include <soo/hypervisor.h>
+
+#include <soo/uapi/console.h>
+
+#ifdef CONFIG_X86
+#include <linux/smp.h>
+#include <opencn/frontend/vlog.h>
+#endif
+
+/* Agency Core */
+static bool log_soo_core = false;
+
+/* Backends */
+static bool log_soo_backend_vsenseled = true;
+static bool log_soo_backend_vuihandler = true;
+
+struct mutex soo_log_lock;
+
+bool __soo_log_lock_initialized = false;
+
+extern int vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
+
+#ifdef CONFIG_X86
+extern bool send_to_uart(char *str);
+extern void smp_kick_vt_out(void);
+
+atomic64_t str_to_print;
+
+#endif
+
+void __lprintk(const char *format, va_list va) {
+	char buf[CONSOLEIO_BUFFER_SIZE];
+	char *__start;
+ 
+	vsnprintf(buf, CONSOLEIO_BUFFER_SIZE, format, va);
+
+	__start = buf;
+
+	/* Skip printk prefix issued by the standard Linux printk if any */
+	if ((*__start != 0) && (*__start < 10))
+		__start += 2;
+        avz_printstr(__start);
+}
+
+void lprintk(char *format, ...) {
+
+	va_list va;
+	va_start(va, format);
+
+	__lprintk(format, va);
+
+	va_end(va);
+}
+
+void __soo_log(char *info, char *buf) {
+	char prefix[50];
+	static char __internal_buf[CONSOLEIO_BUFFER_SIZE] = { };
+
+	bool outlog = false;
+	static bool force_log = false;
+
+	if (__internal_buf[0] == 0) {
+
+		if ((buf[0] == '*') && (buf[1] == '*') && (buf[2] == '*'))
+			force_log = true;
+
+		/* Add log information */
+		sprintf(prefix, "(%s) ", info);
+		strcat(__internal_buf, prefix);
+	}
+
+	strcat(__internal_buf, buf);
+
+	if (buf[strlen(buf)-1] != '\n')
+		return ;
+
+	/* Agency Core */
+	if ((log_soo_core && (strstr(__internal_buf, "[soo:core"))))
+		outlog = true;
+
+	/* Backends */
+	if ((log_soo_backend_vsenseled && (strstr(__internal_buf, "[soo:backend:vsenseled"))) ||
+	    (log_soo_backend_vuihandler && (strstr(__internal_buf, "[soo:backend:vuihandler")))
+	    )
+		outlog = true;
+
+	/* Print out to the console */
+	if (!outlog && !force_log) {
+		__internal_buf[0] = 0;
+		return ;
+	}
+	force_log = false;
+
+	/* Out to the interface...*/
+
+        printk("%s", __internal_buf);
+
+        __internal_buf[0] = 0;
+}
+
+void soo_log(char *format, ...) {
+	va_list va;
+	char buf[CONSOLEIO_BUFFER_SIZE];
+
+	if (unlikely(!__soo_log_lock_initialized)) {
+		mutex_init(&soo_log_lock);
+		__soo_log_lock_initialized = true;
+	}
+
+	mutex_lock(&soo_log_lock);
+
+	va_start(va, format);
+	vsnprintf(buf, CONSOLEIO_BUFFER_SIZE, format, va);
+	va_end(va);
+
+	__soo_log("SOO: ", buf);
+
+	mutex_unlock(&soo_log_lock);
+}
+
+/**
+ * Print the contents of a buffer.
+ */
+void soo_log_buffer(void *buffer, uint32_t n) {
+	uint32_t i;
+
+	for (i = 0 ; i < n ; i++)
+		soo_log("%02x ", ((char *) buffer)[i]);
+}
+
+/**
+ * Print the contents of a buffer.
+ */
+void lprintk_buffer(void *buffer, uint32_t n) {
+	uint32_t i;
+
+	for (i = 0 ; i < n ; i++)
+		lprintk("%02x ", ((char *) buffer)[i]);
+}
+
+/**
+ * Print the contents of a buffer.
+ */
+void printk_buffer(void *buffer, uint32_t n) {
+	uint32_t i;
+
+	for (i = 0 ; i < n ; i++)
+		pr_cont("%02x ", ((char *) buffer)[i]);
+}
+
+/**
+ * Print the contents of a buffer. Each element is separated using a given character.
+ */
+void lprintk_buffer_separator(void *buffer, uint32_t n, char separator) {
+	uint32_t i;
+
+	for (i = 0 ; i < n ; i++)
+		lprintk("%02x%c", ((char *) buffer)[i], separator);
+	lprintk("\n");
+}
+
+/**
+ * Print an uint64_t number and concatenate a string.
+ */
+void lprintk_int64_post(s64 number, char *post) {
+	uint32_t msb = number >> 32;
+	uint32_t lsb = number & 0xffffffff;
+
+	lprintk("%08x %08x%s", msb, lsb, post);
+}
+
+/**
+ * Print an uint64_t number.
+ */
+void lprintk_int64(s64 number) {
+	lprintk_int64_post(number, "\n");
+}
+
+ 
\ No newline at end of file
