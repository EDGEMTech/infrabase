--- /home/rossierd/soo/micofe/build/tmp/work/linux-6.12-r0/linux-6.12/soo/kernel/hypervisor.c	1970-01-01 01:00:00.000000000 +0100
+++ ./soo/kernel/hypervisor.c	2025-08-24 11:46:06.524119460 +0200
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2016-2019 Daniel Rossier <daniel.rossier@soo.tech>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/cpumask.h>
+#include <linux/mm_types.h>
+#include <linux/memblock.h>
+
+#include <asm/pgtable.h>
+
+#include <soo/hypervisor.h>
+#include <soo/evtchn.h>
+#include <soo/paging.h>
+
+#include <soo/uapi/soo.h>
+
+/*
+ * SOO hypercall
+ *
+ * Mandatory arguments:
+ * - cmd: hypercall
+ * - addr: a virtual address used within the hypervisor
+ * - p_val1: a (virtual) address to a first value
+ * - p_val2: a (virtual) address to a second value
+ */
+
+void avz_hypercall(void *args)
+{
+        avz_hyp_t *__avz_hyp, *avz_hyp = (avz_hyp_t *) args;
+
+	/* Make sure the avz_hyp details are in a linear-mapped zone
+	 * to be able to pass the physical address to the hypervisor.
+	 */
+	__avz_hyp = kmalloc(sizeof(avz_hyp_t), GFP_KERNEL);
+        BUG_ON(!__avz_hyp);
+
+        memcpy(__avz_hyp, avz_hyp, sizeof(avz_hyp_t));
+
+        dcache_clean_inval_poc((unsigned long) __avz_hyp, sizeof(avz_hyp_t));
+        __avz_hypercall(AVZ_HYPERCALL_TRAP, virt_to_phys(__avz_hyp));
+       
+        memcpy(avz_hyp, __avz_hyp, sizeof(avz_hyp_t));
+
+        kfree(__avz_hyp);
+}
+
+void avz_get_shared(void) {
+        avz_hyp_t args;
+
+        args.cmd = AVZ_DOMAIN_CONTROL_OP;
+        args.u.avz_domctl_args.domctl.cmd = DOMCTL_get_AVZ_shared;
+
+        avz_hypercall(&args);
+
+        BUG_ON(!args.u.avz_domctl_args.domctl.avz_shared_paddr);
+
+        avz_shared = (volatile avz_shared_t *) paging_remap(args.u.avz_domctl_args.domctl.avz_shared_paddr, PAGE_SIZE);
+	BUG_ON(!avz_shared);
+}
+
+void avz_printch(char c) {
+        avz_hyp_t args;
+
+        args.cmd = AVZ_CONSOLE_IO_OP;
+
+        args.u.avz_console_io_args.console.cmd = CONSOLE_IO_PRINTCH;
+        args.u.avz_console_io_args.console.u.c = c;
+
+        avz_hypercall(&args);
+}
+
+void avz_printstr(char *s) {
+        avz_hyp_t args;
+
+        args.cmd = AVZ_CONSOLE_IO_OP;
+        args.u.avz_console_io_args.console.cmd = CONSOLE_IO_PRINTSTR;
+
+        strncpy(args.u.avz_console_io_args.console.u.str, s, CONSOLE_STR_MAX_LEN);
+       
+        avz_hypercall(&args);
+}
+
+void avz_gnttab(gnttab_op_t *op) {
+        avz_hyp_t args;
+
+        args.cmd = AVZ_GRANT_TABLE_OP;
+
+        memcpy(&args.u.avz_gnttab_args.gnttab_op, op, sizeof(gnttab_op_t));
+        avz_hypercall(&args);
+        memcpy(op, &args.u.avz_gnttab_args.gnttab_op, sizeof(gnttab_op_t));
+}
+
+
