--- /home/rossierd/soo/micofe/build/tmp/work/linux-6.12-r0/linux-6.12/soo/include/avz/uapi/avz.h	1970-01-01 01:00:00.000000000 +0100
+++ ./soo/include/avz/uapi/avz.h	2025-08-24 11:46:06.523448862 +0200
@@ -0,0 +1,304 @@
+/*
+ * Copyright (C) 2016-2022 Daniel Rossier <daniel.rossier@heig-vd.ch>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef UAPI_AVZ_H
+#define UAPI_AVZ_H
+
+#ifndef __ASSEMBLY__
+
+#include <asm/atomic.h>
+
+#endif /* __ASSEMBLY__ */
+
+/*
+ * VIRTUAL INTERRUPTS
+ *
+ * Virtual interrupts that a guest OS may receive from the hypervisor.
+ *
+ */
+#define NR_VIRQS 256
+
+#define VIRQ_TIMER 0 /* System timer tick virtualized interrupt */
+#define VIRQ_TIMER_RT 1 /* Timer tick issued from the oneshot timer (for RT agency and MEs */
+
+/**************************************************/
+
+/*
+ * Commands to HYPERVISOR_console_io().
+ */
+#define CONSOLEIO_write_string 0
+#define CONSOLEIO_process_char 1
+
+/* Idle domain. */
+#define DOMID_IDLE (0x7FFFU)
+
+/* DOMID_SELF is used in certain contexts to refer to oneself. */
+#define DOMID_SELF (0x7FF0U)
+
+#define MAX_ME_DOMAINS 5
+
+/* We include the (non-RT & RT) agency domain */
+#define MAX_DOMAINS (2 + MAX_ME_DOMAINS)
+
+/* Agency */
+#define DOMID_AGENCY 0
+
+/* Realtime agency subdomain */
+#define DOMID_AGENCY_RT 1
+
+#define DOMID_INVALID (0x7FF4U)
+
+#define AVZ_HYPERCALL_TRAP 0x2605
+#define AVZ_HYPERCALL_SIGRETURN 0x2606
+
+#define IPI_EVENT_CHECK  2
+
+#ifndef __ASSEMBLY__
+
+/*
+ * 128 event channels per domain
+ */
+#define NR_EVTCHN 128
+
+#ifndef DOMID_T
+#define DOMID_T
+typedef uint16_t domid_t;
+typedef unsigned long addr_t;
+#endif
+
+/*
+ * Generic hypercalls
+ */
+#define AVZ_EVENT_CHANNEL_OP		1
+#define AVZ_CONSOLE_IO_OP		2
+#define AVZ_DOMAIN_CONTROL_OP           3
+
+#define CONSOLE_STR_MAX_LEN             128
+
+/* Console management */
+
+#define CONSOLE_IO_KEYHANDLER           0
+#define CONSOLE_IO_PRINTCH              1
+#define CONSOLE_IO_PRINTSTR             2
+
+typedef struct {
+        int cmd;
+        union {
+                char c;
+                char str[CONSOLE_STR_MAX_LEN];
+        } u;
+} console_t;
+
+/* AVZ_CONSOLE_IO_OP */
+typedef struct {
+        console_t console;
+} avz_console_io_t;
+
+#define DOMCTL_pauseME       	1
+#define DOMCTL_unpauseME     	2
+#define DOMCTL_get_AVZ_shared	3
+
+struct domctl {
+	uint32_t cmd;
+	domid_t domain;
+	addr_t avz_shared_paddr;
+};
+typedef struct domctl domctl_t;
+
+/* Event channel management */
+
+#define ECS_FREE         0 /* Channel is available for use.                  */
+#define ECS_RESERVED     1 /* Channel is reserved.                           */
+#define ECS_UNBOUND      2 /* Channel is waiting to bind to a remote domain. */
+#define ECS_INTERDOMAIN  3 /* Channel is bound to another domain.            */
+#define ECS_VIRQ         4 /* Channel is bound to a virtual IRQ line.        */
+
+#define EVTCHNSTAT_closed       0  /* Channel is not in use.                 */
+#define EVTCHNSTAT_unbound      1  /* Channel is waiting interdom connection.*/
+#define EVTCHNSTAT_interdomain  2  /* Channel is connected to remote domain. */
+#define EVTCHNSTAT_virq         3  /* Channel is bound to a virtual IRQ line */
+/*
+ * EVTCHNOP_alloc_unbound: Allocate a evtchn in domain <dom> and mark as
+ * accepting interdomain bindings from domain <remote_dom>. A fresh evtchn
+ * is allocated in <dom> and returned as <evtchn>.
+ * NOTES:
+ *  1. If the caller is unprivileged then <dom> must be DOMID_SELF.
+ *  2. <rdom> may be DOMID_SELF, allowing loopback connections.
+ */
+#define EVTCHNOP_alloc_unbound    6
+struct evtchn_alloc_unbound {
+	/* IN parameters */
+	domid_t dom, remote_dom;
+	/* OUT parameters */
+	uint32_t evtchn;
+	uint32_t use;
+};
+typedef struct evtchn_alloc_unbound evtchn_alloc_unbound_t;
+
+/*
+ * EVTCHNOP_bind_interdomain: Construct an interdomain event channel between
+ * the calling domain and <remote_dom>. <remote_dom,remote_evtchn> must identify
+ * a evtchn that is unbound and marked as accepting bindings from the calling
+ * domain. A fresh evtchn is allocated in the calling domain and returned as
+ * <local_evtchn>.
+ * NOTES:
+ *  2. <remote_dom> may be DOMID_SELF, allowing loopback connections.
+ */
+#define EVTCHNOP_bind_interdomain     	      0
+#define EVTCHNOP_bind_existing_interdomain    7
+#define EVTCHNOP_unbind_domain 		      12
+
+struct evtchn_bind_interdomain {
+	/* IN parameters. */
+	domid_t remote_dom;
+	uint32_t remote_evtchn;
+	uint32_t use;
+	/* OUT parameters. */
+	uint32_t local_evtchn;
+};
+typedef struct evtchn_bind_interdomain evtchn_bind_interdomain_t;
+
+#define EVTCHNOP_bind_virq 1
+struct evtchn_bind_virq {
+	/* IN parameters. */
+	uint32_t virq;
+	/* OUT parameters. */
+	uint32_t evtchn;
+};
+typedef struct evtchn_bind_virq evtchn_bind_virq_t;
+
+/*
+ * EVTCHNOP_close: Close a local event channel <evtchn>. If the channel is
+ * interdomain then the remote end is placed in the unbound state
+ * (EVTCHNSTAT_unbound), awaiting a new connection.
+ */
+#define EVTCHNOP_close 3
+struct evtchn_close {
+	/* IN parameters. */
+	uint32_t evtchn;
+};
+typedef struct evtchn_close evtchn_close_t;
+
+/*
+ * EVTCHNOP_send: Send an event to the remote end of the channel whose local
+ * endpoint is <evtchn>.
+ */
+#define EVTCHNOP_send 4
+struct evtchn_send {
+	/* IN parameters. */
+	uint32_t evtchn;
+};
+typedef struct evtchn_send evtchn_send_t;
+
+struct evtchn_op {
+	uint32_t cmd; /* EVTCHNOP_* */
+	union {
+		struct evtchn_alloc_unbound alloc_unbound;
+		struct evtchn_bind_interdomain bind_interdomain;
+		struct evtchn_bind_virq bind_virq;
+		struct evtchn_close close;
+		struct evtchn_send send;
+	} u;
+};
+typedef struct evtchn_op evtchn_op_t;
+
+
+/* AVZ_DOMAIN_CONTROL_OP */
+typedef struct {
+        domctl_t domctl;
+} avz_domctl_t;
+
+/* AVZ_EVENT_CHANNEL_OP */
+typedef struct {
+        evtchn_op_t evtchn_op;
+} avz_evtchn_t;
+
+/* Assembly low-level code to raise up hypercall */
+extern long __avz_hypercall(int vector, long avz_hyp_args);
+
+/* Generic function to raise up hypercall */
+void avz_hypercall(void *avz_hyp);
+
+/*
+ * TODO: Refactor the following declarations to have cleaner separation
+ * between AVZ and SOO.
+ */
+#ifndef CONFIG_SOO
+
+/*
+ * AVZ hypercall argument
+ */
+typedef struct {
+        int cmd;
+	union {
+                avz_evtchn_t avz_evtchn;
+                avz_console_io_t avz_console_io_args;
+                avz_domctl_t avz_domctl_args;
+        } u;
+} avz_hyp_t;
+
+/*
+ * Shared info page, shared between AVZ and the domain.
+ */
+struct avz_shared {
+	domid_t domID;
+
+	/* Domain related information */
+	unsigned long nr_pages; /* Total pages allocated to this domain.  */
+
+	addr_t fdt_paddr;
+
+	/* Other fields related to domain life */
+
+	unsigned long domain_stack;
+	uint8_t evtchn_upcall_pending;
+
+	/*
+	 * A domain can create "event channels" on which it can send and receive
+	 * asynchronous event notifications.
+	 * Each event channel is assigned a bit in evtchn_pending and its modification has to be
+	 * kept atomic.
+	 */
+
+	volatile bool evtchn_pending[NR_EVTCHN];
+
+	atomic_t dc_event;
+
+	/* This field is used when taking a snapshot of us. It will be
+	 * useful to restore later. Some timer deadlines are based on it and
+	 * will need to be updated accordingly.
+	 */
+	u64 current_s_time;
+
+	/* Used to store a signature for consistency checking, for example after a migration/restoration */
+	char signature[4];
+};
+
+#endif /* !CONFIG_SOO */
+
+typedef struct avz_shared avz_shared_t;
+extern volatile avz_shared_t *avz_shared;
+
+void do_avz_hypercall(void *args);
+void __sigreturn(void);
+void virq_handle(unsigned irq_nr);
+void virq_init(void);
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* UAPI_AVZ_H */
